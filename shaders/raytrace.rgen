#version 460 core

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_debug_printf : enable
#extension GL_GOOGLE_include_directive : require

layout(push_constant) uniform ScreenDim {
	vec3 worldOffset;
	float aspectRatio;
	float tanHalfFoV;
	float time;
	uint accumulatedSampleCount;
};

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlasStructure;
layout(rgba32f, set = 0, binding = 1) restrict uniform image2D accumulationImage;
layout(rgba8, set = 0, binding = 2) uniform image2D outputImage;

 #include "raytrace-common.glsl"

layout(location = 0) rayPayloadEXT RayPayload payload;

void nextRand(inout uint randomState) {
	randomState = randomState * 246049789 % 268435399;
	uint c = randomState & 0xE0000000 >> 29;
	randomState = ((((randomState ^ randomState >> c)) ^ (c << 32 - c)) * 104122896) ^ (c << 7);
}

const uint nSamples = 16;

void main() {
	vec4 prevAccumulatedRadiance = imageLoad(accumulationImage, ivec2(gl_LaunchIDEXT.xy));

	if(accumulatedSampleCount == -1U) {
		//prevAccumulatedRadiance = prevAccumulatedRadiance / (prevAccumulatedRadiance + vec4(1.0f, 1.0f, 1.0f, 0.0f));
		prevAccumulatedRadiance = pow(prevAccumulatedRadiance, 1.0f / 2.2f.xxxx);
		imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), prevAccumulatedRadiance);
		return;
	}

	vec2 point = (vec2(gl_LaunchIDEXT.xy) / vec2(gl_LaunchSizeEXT.xy)) * 2.0f.xx - 1.0f.xx;
	vec3 origin = vec3(0.0f, 0.0f, 0.1f) + vec3(point * vec2(tanHalfFoV * aspectRatio, tanHalfFoV), 0.0f) * 0.1f;
	vec3 projected = vec3(0.0f, 0.0f, 1.0f) + vec3(point * vec2(tanHalfFoV * aspectRatio, tanHalfFoV), 0.0f);

	//stratified sampling for the two image dimensions

	vec2 pixelSizeWorldSpace = vec2(tanHalfFoV * aspectRatio, tanHalfFoV) / vec2(gl_LaunchSizeEXT.xy);

	uint randomSeed = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + floatBitsToUint(time);
	nextRand(randomSeed);

	vec2 pixelJitter;
	pixelJitter.x = randomSeed * uintBitsToFloat(0x2f800004U);
	nextRand(randomSeed);
	pixelJitter.y = randomSeed * uintBitsToFloat(0x2f800004U);
	pixelJitter -= 1.0f; //pixelJitter is in [-0.5;0.5]

	vec4 accumulatedRadiance = vec4(0.0f);
	for(uint i = 0; i < nSamples; ++i) {
		payload.randomState = randomSeed;
		payload.rayThroughput = 1.0f;
		payload.isLightSample = false;
		payload.color = vec4(0.0f);
		payload.recursionDepth = 0;

		traceRayEXT(tlasStructure, gl_RayFlagsNoneEXT, 0xFF, 0, 0, 0, worldOffset, 0.0, normalize(projected - origin), 999999999.0f, 0);
		accumulatedRadiance += payload.color / nSamples;
	}

	if(accumulatedSampleCount > 1)
		accumulatedRadiance = prevAccumulatedRadiance * (1 - 1.0f / accumulatedSampleCount) + accumulatedRadiance * (1.0f / accumulatedSampleCount);

	if(any(isnan(accumulatedRadiance))) {
		accumulatedRadiance = vec4(1.0f, 0.0f, 0.0f ,1.0f);
	}
	
	imageStore(accumulationImage, ivec2(gl_LaunchIDEXT.xy), accumulatedRadiance);

	//accumulatedRadiance = accumulatedRadiance / (accumulatedRadiance + vec4(1.0f, 1.0f, 1.0f, 0.0f));
	accumulatedRadiance = pow(accumulatedRadiance, 1.0f / 2.2f.xxxx);
	imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), accumulatedRadiance);
}